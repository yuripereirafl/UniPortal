#!/usr/bin/env bash
set -euo pipefail

# vm-deploy.sh
# Safe deploy script for the VM. What it does:
#  - optional: backup .env
#  - ensure repo is on main and reset to origin/main (destructive if you have local changes)
#  - ensure a working .env exists and points DB_HOST to the remote DB
#  - run docker compose up only for backend and frontend (no deps => won't start 'db')
#  - tail logs and run a quick healthcheck
#
# Usage: ./vm-deploy.sh [--no-git-reset] [--db-host 192.168.1.37] [--env-file .env]

REPO_ROOT="$(cd "$(dirname "$0")" && pwd)"
ENV_FILE="${REPO_ROOT}/.env"
GIT_RESET=true
DB_HOST_OVERRIDE=""

print_usage() {
	cat <<EOF
Usage: $0 [--no-git-reset] [--db-host <host>] [--env-file <path>]

Options:
	--no-git-reset    Skip the destructive git reset --hard origin/main (keeps local changes)
	--db-host         Set DB_HOST in the .env (default: 192.168.1.37 if not present)
	--env-file        Path to env file to use (default: ./ .env)
EOF
}

while [[ ${#} -gt 0 ]]; do
	case "$1" in
		--no-git-reset)
			GIT_RESET=false; shift ;;
		--db-host)
			DB_HOST_OVERRIDE="$2"; shift 2 ;;
		--env-file)
			ENV_FILE="$2"; shift 2 ;;
		-h|--help)
			print_usage; exit 0 ;;
		*)
			echo "Unknown arg: $1"; print_usage; exit 1 ;;
	esac
done

echo "Repo root: $REPO_ROOT"
echo "Using env file: $ENV_FILE"

cd "$REPO_ROOT"

### 1) Optional destructive git reset to origin/main (keeps behaviour simple on the VM)
if [ "$GIT_RESET" = true ]; then
	echo "--> Fetching origin and resetting local main to origin/main (destructive)."
	git fetch origin
	# switch to main
	git checkout main || git switch main
	echo "--> Resetting to origin/main"
	git reset --hard origin/main
	git clean -fd
else
	echo "--> Skipping git reset (local changes preserved)."
fi

### 2) Ensure .env exists and has DB_HOST set to a sensible default if not provided
if [ ! -f "$ENV_FILE" ]; then
	echo "--> .env not found at $ENV_FILE. Creating from template values."
	cat > "$ENV_FILE" <<EOF
# generated by vm-deploy.sh - adjust values as needed
FRONTEND_PORT=8080
BACKEND_PORT=8000

DB_HOST=${DB_HOST_OVERRIDE:-192.168.1.37}
DB_PORT=5432
DB_NAME=dadosrh
DB_USER=dadosrh
DB_PASSWORD=dadosrh

API_URL=http://
VUE_APP_API_URL=http://

COMPOSE_PROJECT_NAME=system-ti
EOF
	echo "--> .env created at $ENV_FILE"
else
	echo "--> .env exists. Backing up to ${ENV_FILE}.bak"
	cp -f "$ENV_FILE" "${ENV_FILE}.bak"
	# ensure DB_HOST is set
	if grep -qE '^DB_HOST=' "$ENV_FILE"; then
		if [ -n "$DB_HOST_OVERRIDE" ]; then
			sed -i "s~^DB_HOST=.*~DB_HOST=${DB_HOST_OVERRIDE}~" "$ENV_FILE"
			echo "--> Replaced DB_HOST in $ENV_FILE with $DB_HOST_OVERRIDE"
		else
			echo "--> DB_HOST already present in $ENV_FILE"
		fi
	else
		DEFAULT_HOST=${DB_HOST_OVERRIDE:-192.168.1.37}
		echo "DB_HOST=${DEFAULT_HOST}" >> "$ENV_FILE"
		echo "--> Appended DB_HOST=${DEFAULT_HOST} to $ENV_FILE"
	fi
fi

### 3) Validate docker compose config
echo "--> Validating docker compose config (will show DB_HOST/ports):"
docker compose --env-file "$ENV_FILE" -f docker-compose.yml -f docker-compose.override.yml config | grep -E "DB_HOST|DB_PORT|HOST_DB_PORT|INTERNAL_DB_PORT" || true

### 4) Test TCP connectivity to DB (quick check)
DB_TEST_HOST=$(grep -E '^DB_HOST=' "$ENV_FILE" | cut -d'=' -f2- || true)
if [ -n "$DB_TEST_HOST" ]; then
	echo "--> Testing TCP connectivity to DB host: $DB_TEST_HOST:5432"
	if command -v nc >/dev/null 2>&1; then
		nc -vz "$DB_TEST_HOST" 5432 || echo "WARNING: nc could not connect to $DB_TEST_HOST:5432"
	else
		# fallback to timeout + bash /dev/tcp
		(timeout 5 bash -c "/dev/tcp/${DB_TEST_HOST}/5432") >/dev/null 2>&1 && echo "TCP OK" || echo "WARNING: TCP test failed (no nc)"
	fi
else
	echo "--> DB_TEST_HOST is empty; skipping TCP test"
fi

### 5) Start only backend and frontend (do not create local db)
echo "--> Starting backend and frontend only (no-deps)..."
docker compose --env-file "$ENV_FILE" -f docker-compose.yml -f docker-compose.override.yml up -d --build --no-deps backend frontend

echo "--> Waiting a few seconds for services to initialize..."
sleep 4

### 6) Status and logs
docker compose ps
echo "--> Last 200 lines of backend logs:" 
docker compose logs backend --no-log-prefix --tail=200 || true

### 7) Quick healthcheck for backend /docs
echo "--> Quick healthcheck: http://localhost:8000/docs"
if command -v curl >/dev/null 2>&1; then
	curl -sS --head http://localhost:8000/docs | sed -n '1,20p' || true
else
	echo "curl not found; skip HTTP healthcheck"
fi

echo "--> vm-deploy.sh finished. If backend failed to connect to DB, check logs above and verify DB credentials and pg_hba.conf on the DB server."
